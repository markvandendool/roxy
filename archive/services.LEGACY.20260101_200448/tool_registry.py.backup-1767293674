#!/usr/bin/env python3
"""
ROXY Tool Registry - Function/Tool Calling Framework
Enables ROXY to execute real actions, not just generate text
Industry Standard: OpenAI Functions, LangChain Tools, AutoGen
"""
import logging
import asyncio
from typing import Dict, Any, List, Optional, Callable, Union
from dataclasses import dataclass
from enum import Enum
import json

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('roxy.tools')

class ToolType(Enum):
    FILE_OPERATION = "file_operation"
    CODE_OPERATION = "code_operation"
    SYSTEM_OPERATION = "system_operation"
    SEARCH_OPERATION = "search_operation"
    EXECUTION_OPERATION = "execution_operation"

@dataclass
class Tool:
    """Tool definition for function calling"""
    name: str
    description: str
    parameters: Dict[str, Any]  # JSON Schema format
    handler: Callable
    tool_type: ToolType
    requires_auth: bool = False
    dangerous: bool = False

class ToolRegistry:
    """Central registry for all ROXY tools"""
    
    def __init__(self):
        self.tools: Dict[str, Tool] = {}
        self._register_default_tools()
    
    def register(self, tool: Tool):
        """Register a tool"""
        self.tools[tool.name] = tool
        logger.info(f"ðŸ”§ Registered tool: {tool.name}")
    
    def get_tool(self, name: str) -> Optional[Tool]:
        """Get tool by name"""
        return self.tools.get(name)
    
    def list_tools(self) -> List[Dict]:
        """List all available tools"""
        return [
            {
                'name': tool.name,
                'description': tool.description,
                'type': tool.tool_type.value,
                'parameters': tool.parameters,
                'requires_auth': tool.requires_auth,
                'dangerous': tool.dangerous
            }
            for tool in self.tools.values()
        ]
    
    def get_tools_for_llm(self) -> List[Dict]:
        """Get tools in OpenAI Functions format for LLM"""
        return [
            {
                'type': 'function',
                'function': {
                    'name': tool.name,
                    'description': tool.description,
                    'parameters': tool.parameters
                }
            }
            for tool in self.tools.values()
        ]
    
    async def execute_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a tool with given arguments"""
        tool = self.get_tool(tool_name)
        if not tool:
            return {'error': f'Tool {tool_name} not found'}
        
        try:
            # Validate arguments
            if tool.requires_auth:
                # TODO: Add auth check
                pass
            
            # Execute tool
            if asyncio.iscoroutinefunction(tool.handler):
                result = await tool.handler(**arguments)
            else:
                result = tool.handler(**arguments)
            
            return {
                'success': True,
                'tool': tool_name,
                'result': result
            }
        except Exception as e:
            logger.error(f"Tool execution error: {e}")
            return {
                'success': False,
                'tool': tool_name,
                'error': str(e)
            }
    
    def _register_default_tools(self):
        """Register default tools"""
        from pathlib import Path
        import os
        
        # File Operations
        self.register(Tool(
            name="list_files",
            description="List files in a directory. Use this for 'list pages', 'list files', 'list components' queries.",
            parameters={
                "type": "object",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "Directory path to list files from"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "File pattern to match (e.g., '*.tsx', '*.py')"
                    },
                    "recursive": {
                        "type": "boolean",
                        "description": "Whether to search recursively"
                    }
                },
                "required": ["path"]
            },
            handler=self._list_files_handler,
            tool_type=ToolType.FILE_OPERATION
        ))
        
        self.register(Tool(
            name="read_file",
            description="Read contents of a file",
            parameters={
                "type": "object",
                "properties": {
                    "file_path": {
                        "type": "string",
                        "description": "Path to file to read"
                    },
                    "lines": {
                        "type": "array",
                        "items": {"type": "integer"},
                        "description": "Specific line numbers to read (optional)"
                    }
                },
                "required": ["file_path"]
            },
            handler=self._read_file_handler,
            tool_type=ToolType.FILE_OPERATION
        ))
        
        self.register(Tool(
            name="search_code",
            description="Search for code patterns in repository",
            parameters={
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "Search query (code pattern, function name, etc.)"
                    },
                    "file_type": {
                        "type": "string",
                        "description": "File extension filter (e.g., '.py', '.tsx')"
                    },
                    "max_results": {
                        "type": "integer",
                        "description": "Maximum number of results"
                    }
                },
                "required": ["query"]
            },
            handler=self._search_code_handler,
            tool_type=ToolType.SEARCH_OPERATION
        ))
        
        self.register(Tool(
            name="execute_command",
            description="Execute a shell command (use with caution)",
            parameters={
                "type": "object",
                "properties": {
                    "command": {
                        "type": "string",
                        "description": "Shell command to execute"
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Timeout in seconds"
                    }
                },
                "required": ["command"]
            },
            handler=self._execute_command_handler,
            tool_type=ToolType.EXECUTION_OPERATION,
            dangerous=True
        ))
    
    def _list_files_handler(self, path: str, pattern: str = None, recursive: bool = True) -> Dict:
        """Handler for list_files tool"""
        try:
            from pathlib import Path
            repo = Path(path)
            if not repo.exists():
                return {'error': f'Path not found: {path}'}
            
            files = []
            if recursive:
                if pattern:
                    files = list(repo.rglob(pattern))
                else:
                    files = list(repo.rglob('*'))
            else:
                if pattern:
                    files = list(repo.glob(pattern))
                else:
                    files = list(repo.iterdir())
            
            # Filter out hidden files and common exclusions
            filtered = [
                str(f.relative_to(repo)) for f in files
                if f.is_file() and not any(skip in str(f) for skip in [
                    '.git', 'node_modules', '__pycache__', '.next', 'dist', 'build'
                ])
            ]
            
            return {
                'path': path,
                'count': len(filtered),
                'files': filtered[:100]  # Limit to 100 files
            }
        except Exception as e:
            return {'error': str(e)}
    
    def _read_file_handler(self, file_path: str, lines: List[int] = None) -> Dict:
        """Handler for read_file tool"""
        try:
            from pathlib import Path
            file = Path(file_path)
            if not file.exists():
                return {'error': f'File not found: {file_path}'}
            
            content = file.read_text(encoding='utf-8', errors='ignore')
            
            if lines:
                content_lines = content.split('\n')
                selected = [content_lines[i-1] for i in lines if 1 <= i <= len(content_lines)]
                return {
                    'file_path': file_path,
                    'lines': lines,
                    'content': '\n'.join(selected)
                }
            
            return {
                'file_path': file_path,
                'content': content,
                'size': len(content),
                'lines': len(content.split('\n'))
            }
        except Exception as e:
            return {'error': str(e)}
    
    def _search_code_handler(self, query: str, file_type: str = None, max_results: int = 10) -> Dict:
        """Handler for search_code tool"""
        try:
            import os
            # Use repository RAG if available
            from repository_rag import get_repo_rag
            repo_path = "/home/mark/mindsong-juke-hub"
            if os.path.exists(repo_path):
                rag = get_repo_rag(repo_path)
                results = rag.search_code(query, file_type=file_type)
                return {
                    'query': query,
                    'results': results[:max_results],
                    'count': len(results)
                }
            else:
                return {'error': 'Repository not found for code search'}
        except Exception as e:
            return {'error': str(e)}
    
    def _execute_command_handler(self, command: str, timeout: int = 30) -> Dict:
        """Handler for execute_command tool"""
        try:
            import subprocess
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            return {
                'command': command,
                'exit_code': result.returncode,
                'stdout': result.stdout,
                'stderr': result.stderr
            }
        except subprocess.TimeoutExpired:
            return {'error': f'Command timed out after {timeout}s'}
        except Exception as e:
            return {'error': str(e)}


# Global registry instance
_registry: Optional[ToolRegistry] = None

def get_tool_registry() -> ToolRegistry:
    """Get global tool registry instance"""
    global _registry
    if _registry is None:
        _registry = ToolRegistry()
    return _registry

